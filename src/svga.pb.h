// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svga.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_svga_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_svga_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_svga_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_svga_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_svga_2eproto;
namespace com {
namespace opensource {
namespace svga {
class AudioEntity;
class AudioEntityDefaultTypeInternal;
extern AudioEntityDefaultTypeInternal _AudioEntity_default_instance_;
class FrameEntity;
class FrameEntityDefaultTypeInternal;
extern FrameEntityDefaultTypeInternal _FrameEntity_default_instance_;
class Layout;
class LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class MovieEntity;
class MovieEntityDefaultTypeInternal;
extern MovieEntityDefaultTypeInternal _MovieEntity_default_instance_;
class MovieEntity_ImagesEntry_DoNotUse;
class MovieEntity_ImagesEntry_DoNotUseDefaultTypeInternal;
extern MovieEntity_ImagesEntry_DoNotUseDefaultTypeInternal _MovieEntity_ImagesEntry_DoNotUse_default_instance_;
class MovieParams;
class MovieParamsDefaultTypeInternal;
extern MovieParamsDefaultTypeInternal _MovieParams_default_instance_;
class ShapeEntity;
class ShapeEntityDefaultTypeInternal;
extern ShapeEntityDefaultTypeInternal _ShapeEntity_default_instance_;
class ShapeEntity_EllipseArgs;
class ShapeEntity_EllipseArgsDefaultTypeInternal;
extern ShapeEntity_EllipseArgsDefaultTypeInternal _ShapeEntity_EllipseArgs_default_instance_;
class ShapeEntity_RectArgs;
class ShapeEntity_RectArgsDefaultTypeInternal;
extern ShapeEntity_RectArgsDefaultTypeInternal _ShapeEntity_RectArgs_default_instance_;
class ShapeEntity_ShapeArgs;
class ShapeEntity_ShapeArgsDefaultTypeInternal;
extern ShapeEntity_ShapeArgsDefaultTypeInternal _ShapeEntity_ShapeArgs_default_instance_;
class ShapeEntity_ShapeStyle;
class ShapeEntity_ShapeStyleDefaultTypeInternal;
extern ShapeEntity_ShapeStyleDefaultTypeInternal _ShapeEntity_ShapeStyle_default_instance_;
class ShapeEntity_ShapeStyle_RGBAColor;
class ShapeEntity_ShapeStyle_RGBAColorDefaultTypeInternal;
extern ShapeEntity_ShapeStyle_RGBAColorDefaultTypeInternal _ShapeEntity_ShapeStyle_RGBAColor_default_instance_;
class SpriteEntity;
class SpriteEntityDefaultTypeInternal;
extern SpriteEntityDefaultTypeInternal _SpriteEntity_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
}  // namespace svga
}  // namespace opensource
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::opensource::svga::AudioEntity* Arena::CreateMaybeMessage<::com::opensource::svga::AudioEntity>(Arena*);
template<> ::com::opensource::svga::FrameEntity* Arena::CreateMaybeMessage<::com::opensource::svga::FrameEntity>(Arena*);
template<> ::com::opensource::svga::Layout* Arena::CreateMaybeMessage<::com::opensource::svga::Layout>(Arena*);
template<> ::com::opensource::svga::MovieEntity* Arena::CreateMaybeMessage<::com::opensource::svga::MovieEntity>(Arena*);
template<> ::com::opensource::svga::MovieEntity_ImagesEntry_DoNotUse* Arena::CreateMaybeMessage<::com::opensource::svga::MovieEntity_ImagesEntry_DoNotUse>(Arena*);
template<> ::com::opensource::svga::MovieParams* Arena::CreateMaybeMessage<::com::opensource::svga::MovieParams>(Arena*);
template<> ::com::opensource::svga::ShapeEntity* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity>(Arena*);
template<> ::com::opensource::svga::ShapeEntity_EllipseArgs* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity_EllipseArgs>(Arena*);
template<> ::com::opensource::svga::ShapeEntity_RectArgs* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity_RectArgs>(Arena*);
template<> ::com::opensource::svga::ShapeEntity_ShapeArgs* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeArgs>(Arena*);
template<> ::com::opensource::svga::ShapeEntity_ShapeStyle* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeStyle>(Arena*);
template<> ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* Arena::CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor>(Arena*);
template<> ::com::opensource::svga::SpriteEntity* Arena::CreateMaybeMessage<::com::opensource::svga::SpriteEntity>(Arena*);
template<> ::com::opensource::svga::Transform* Arena::CreateMaybeMessage<::com::opensource::svga::Transform>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace opensource {
namespace svga {

enum ShapeEntity_ShapeStyle_LineCap : int {
  ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT = 0,
  ShapeEntity_ShapeStyle_LineCap_LineCap_ROUND = 1,
  ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE = 2,
  ShapeEntity_ShapeStyle_LineCap_ShapeEntity_ShapeStyle_LineCap_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ShapeEntity_ShapeStyle_LineCap_ShapeEntity_ShapeStyle_LineCap_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ShapeEntity_ShapeStyle_LineCap_IsValid(int value);
constexpr ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle_LineCap_LineCap_MIN = ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT;
constexpr ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle_LineCap_LineCap_MAX = ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE;
constexpr int ShapeEntity_ShapeStyle_LineCap_LineCap_ARRAYSIZE = ShapeEntity_ShapeStyle_LineCap_LineCap_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeEntity_ShapeStyle_LineCap_descriptor();
template<typename T>
inline const std::string& ShapeEntity_ShapeStyle_LineCap_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeEntity_ShapeStyle_LineCap>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeEntity_ShapeStyle_LineCap_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeEntity_ShapeStyle_LineCap_descriptor(), enum_t_value);
}
inline bool ShapeEntity_ShapeStyle_LineCap_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeEntity_ShapeStyle_LineCap* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeEntity_ShapeStyle_LineCap>(
    ShapeEntity_ShapeStyle_LineCap_descriptor(), name, value);
}
enum ShapeEntity_ShapeStyle_LineJoin : int {
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER = 0,
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_ROUND = 1,
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL = 2,
  ShapeEntity_ShapeStyle_LineJoin_ShapeEntity_ShapeStyle_LineJoin_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ShapeEntity_ShapeStyle_LineJoin_ShapeEntity_ShapeStyle_LineJoin_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ShapeEntity_ShapeStyle_LineJoin_IsValid(int value);
constexpr ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle_LineJoin_LineJoin_MIN = ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER;
constexpr ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX = ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL;
constexpr int ShapeEntity_ShapeStyle_LineJoin_LineJoin_ARRAYSIZE = ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeEntity_ShapeStyle_LineJoin_descriptor();
template<typename T>
inline const std::string& ShapeEntity_ShapeStyle_LineJoin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeEntity_ShapeStyle_LineJoin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeEntity_ShapeStyle_LineJoin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeEntity_ShapeStyle_LineJoin_descriptor(), enum_t_value);
}
inline bool ShapeEntity_ShapeStyle_LineJoin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeEntity_ShapeStyle_LineJoin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeEntity_ShapeStyle_LineJoin>(
    ShapeEntity_ShapeStyle_LineJoin_descriptor(), name, value);
}
enum ShapeEntity_ShapeType : int {
  ShapeEntity_ShapeType_SHAPE = 0,
  ShapeEntity_ShapeType_RECT = 1,
  ShapeEntity_ShapeType_ELLIPSE = 2,
  ShapeEntity_ShapeType_KEEP = 3,
  ShapeEntity_ShapeType_ShapeEntity_ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ShapeEntity_ShapeType_ShapeEntity_ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ShapeEntity_ShapeType_IsValid(int value);
constexpr ShapeEntity_ShapeType ShapeEntity_ShapeType_ShapeType_MIN = ShapeEntity_ShapeType_SHAPE;
constexpr ShapeEntity_ShapeType ShapeEntity_ShapeType_ShapeType_MAX = ShapeEntity_ShapeType_KEEP;
constexpr int ShapeEntity_ShapeType_ShapeType_ARRAYSIZE = ShapeEntity_ShapeType_ShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeEntity_ShapeType_descriptor();
template<typename T>
inline const std::string& ShapeEntity_ShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeEntity_ShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeEntity_ShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeEntity_ShapeType_descriptor(), enum_t_value);
}
inline bool ShapeEntity_ShapeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeEntity_ShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeEntity_ShapeType>(
    ShapeEntity_ShapeType_descriptor(), name, value);
}
// ===================================================================

class MovieParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.MovieParams) */ {
 public:
  inline MovieParams() : MovieParams(nullptr) {}
  virtual ~MovieParams();

  MovieParams(const MovieParams& from);
  MovieParams(MovieParams&& from) noexcept
    : MovieParams() {
    *this = ::std::move(from);
  }

  inline MovieParams& operator=(const MovieParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieParams& operator=(MovieParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MovieParams& default_instance();

  static inline const MovieParams* internal_default_instance() {
    return reinterpret_cast<const MovieParams*>(
               &_MovieParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MovieParams& a, MovieParams& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovieParams* New() const final {
    return CreateMaybeMessage<MovieParams>(nullptr);
  }

  MovieParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovieParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovieParams& from);
  void MergeFrom(const MovieParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.MovieParams";
  }
  protected:
  explicit MovieParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewBoxWidthFieldNumber = 1,
    kViewBoxHeightFieldNumber = 2,
    kFpsFieldNumber = 3,
    kFramesFieldNumber = 4,
  };
  // float viewBoxWidth = 1;
  void clear_viewboxwidth();
  float viewboxwidth() const;
  void set_viewboxwidth(float value);
  private:
  float _internal_viewboxwidth() const;
  void _internal_set_viewboxwidth(float value);
  public:

  // float viewBoxHeight = 2;
  void clear_viewboxheight();
  float viewboxheight() const;
  void set_viewboxheight(float value);
  private:
  float _internal_viewboxheight() const;
  void _internal_set_viewboxheight(float value);
  public:

  // int32 fps = 3;
  void clear_fps();
  ::PROTOBUF_NAMESPACE_ID::int32 fps() const;
  void set_fps(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fps() const;
  void _internal_set_fps(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 frames = 4;
  void clear_frames();
  ::PROTOBUF_NAMESPACE_ID::int32 frames() const;
  void set_frames(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_frames() const;
  void _internal_set_frames(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.MovieParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float viewboxwidth_;
  float viewboxheight_;
  ::PROTOBUF_NAMESPACE_ID::int32 fps_;
  ::PROTOBUF_NAMESPACE_ID::int32 frames_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class SpriteEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.SpriteEntity) */ {
 public:
  inline SpriteEntity() : SpriteEntity(nullptr) {}
  virtual ~SpriteEntity();

  SpriteEntity(const SpriteEntity& from);
  SpriteEntity(SpriteEntity&& from) noexcept
    : SpriteEntity() {
    *this = ::std::move(from);
  }

  inline SpriteEntity& operator=(const SpriteEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpriteEntity& operator=(SpriteEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpriteEntity& default_instance();

  static inline const SpriteEntity* internal_default_instance() {
    return reinterpret_cast<const SpriteEntity*>(
               &_SpriteEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpriteEntity& a, SpriteEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(SpriteEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpriteEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpriteEntity* New() const final {
    return CreateMaybeMessage<SpriteEntity>(nullptr);
  }

  SpriteEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpriteEntity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpriteEntity& from);
  void MergeFrom(const SpriteEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpriteEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.SpriteEntity";
  }
  protected:
  explicit SpriteEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 2,
    kImageKeyFieldNumber = 1,
    kMatteKeyFieldNumber = 3,
  };
  // repeated .com.opensource.svga.FrameEntity frames = 2;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::com::opensource::svga::FrameEntity* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::FrameEntity >*
      mutable_frames();
  private:
  const ::com::opensource::svga::FrameEntity& _internal_frames(int index) const;
  ::com::opensource::svga::FrameEntity* _internal_add_frames();
  public:
  const ::com::opensource::svga::FrameEntity& frames(int index) const;
  ::com::opensource::svga::FrameEntity* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::FrameEntity >&
      frames() const;

  // string imageKey = 1;
  void clear_imagekey();
  const std::string& imagekey() const;
  void set_imagekey(const std::string& value);
  void set_imagekey(std::string&& value);
  void set_imagekey(const char* value);
  void set_imagekey(const char* value, size_t size);
  std::string* mutable_imagekey();
  std::string* release_imagekey();
  void set_allocated_imagekey(std::string* imagekey);
  private:
  const std::string& _internal_imagekey() const;
  void _internal_set_imagekey(const std::string& value);
  std::string* _internal_mutable_imagekey();
  public:

  // string matteKey = 3;
  void clear_mattekey();
  const std::string& mattekey() const;
  void set_mattekey(const std::string& value);
  void set_mattekey(std::string&& value);
  void set_mattekey(const char* value);
  void set_mattekey(const char* value, size_t size);
  std::string* mutable_mattekey();
  std::string* release_mattekey();
  void set_allocated_mattekey(std::string* mattekey);
  private:
  const std::string& _internal_mattekey() const;
  void _internal_set_mattekey(const std::string& value);
  std::string* _internal_mutable_mattekey();
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.SpriteEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::FrameEntity > frames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagekey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mattekey_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class AudioEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.AudioEntity) */ {
 public:
  inline AudioEntity() : AudioEntity(nullptr) {}
  virtual ~AudioEntity();

  AudioEntity(const AudioEntity& from);
  AudioEntity(AudioEntity&& from) noexcept
    : AudioEntity() {
    *this = ::std::move(from);
  }

  inline AudioEntity& operator=(const AudioEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioEntity& operator=(AudioEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioEntity& default_instance();

  static inline const AudioEntity* internal_default_instance() {
    return reinterpret_cast<const AudioEntity*>(
               &_AudioEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AudioEntity& a, AudioEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioEntity* New() const final {
    return CreateMaybeMessage<AudioEntity>(nullptr);
  }

  AudioEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioEntity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioEntity& from);
  void MergeFrom(const AudioEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.AudioEntity";
  }
  protected:
  explicit AudioEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioKeyFieldNumber = 1,
    kStartFrameFieldNumber = 2,
    kEndFrameFieldNumber = 3,
    kStartTimeFieldNumber = 4,
    kTotalTimeFieldNumber = 5,
  };
  // string audioKey = 1;
  void clear_audiokey();
  const std::string& audiokey() const;
  void set_audiokey(const std::string& value);
  void set_audiokey(std::string&& value);
  void set_audiokey(const char* value);
  void set_audiokey(const char* value, size_t size);
  std::string* mutable_audiokey();
  std::string* release_audiokey();
  void set_allocated_audiokey(std::string* audiokey);
  private:
  const std::string& _internal_audiokey() const;
  void _internal_set_audiokey(const std::string& value);
  std::string* _internal_mutable_audiokey();
  public:

  // int32 startFrame = 2;
  void clear_startframe();
  ::PROTOBUF_NAMESPACE_ID::int32 startframe() const;
  void set_startframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_startframe() const;
  void _internal_set_startframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 endFrame = 3;
  void clear_endframe();
  ::PROTOBUF_NAMESPACE_ID::int32 endframe() const;
  void set_endframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_endframe() const;
  void _internal_set_endframe(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 startTime = 4;
  void clear_starttime();
  ::PROTOBUF_NAMESPACE_ID::int32 starttime() const;
  void set_starttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_starttime() const;
  void _internal_set_starttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 totalTime = 5;
  void clear_totaltime();
  ::PROTOBUF_NAMESPACE_ID::int32 totaltime() const;
  void set_totaltime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_totaltime() const;
  void _internal_set_totaltime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.AudioEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audiokey_;
  ::PROTOBUF_NAMESPACE_ID::int32 startframe_;
  ::PROTOBUF_NAMESPACE_ID::int32 endframe_;
  ::PROTOBUF_NAMESPACE_ID::int32 starttime_;
  ::PROTOBUF_NAMESPACE_ID::int32 totaltime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class Layout PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.Layout) */ {
 public:
  inline Layout() : Layout(nullptr) {}
  virtual ~Layout();

  Layout(const Layout& from);
  Layout(Layout&& from) noexcept
    : Layout() {
    *this = ::std::move(from);
  }

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layout& operator=(Layout&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Layout& default_instance();

  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Layout& a, Layout& b) {
    a.Swap(&b);
  }
  inline void Swap(Layout* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Layout* New() const final {
    return CreateMaybeMessage<Layout>(nullptr);
  }

  Layout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Layout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Layout& from);
  void MergeFrom(const Layout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.Layout";
  }
  protected:
  explicit Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.Layout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float width_;
  float height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class Transform PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.Transform) */ {
 public:
  inline Transform() : Transform(nullptr) {}
  virtual ~Transform();

  Transform(const Transform& from);
  Transform(Transform&& from) noexcept
    : Transform() {
    *this = ::std::move(from);
  }

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transform& operator=(Transform&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transform& default_instance();

  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Transform& a, Transform& b) {
    a.Swap(&b);
  }
  inline void Swap(Transform* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transform* New() const final {
    return CreateMaybeMessage<Transform>(nullptr);
  }

  Transform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transform>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.Transform";
  }
  protected:
  explicit Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kBFieldNumber = 2,
    kCFieldNumber = 3,
    kDFieldNumber = 4,
    kTxFieldNumber = 5,
    kTyFieldNumber = 6,
  };
  // float a = 1;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // float b = 2;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float c = 3;
  void clear_c();
  float c() const;
  void set_c(float value);
  private:
  float _internal_c() const;
  void _internal_set_c(float value);
  public:

  // float d = 4;
  void clear_d();
  float d() const;
  void set_d(float value);
  private:
  float _internal_d() const;
  void _internal_set_d(float value);
  public:

  // float tx = 5;
  void clear_tx();
  float tx() const;
  void set_tx(float value);
  private:
  float _internal_tx() const;
  void _internal_set_tx(float value);
  public:

  // float ty = 6;
  void clear_ty();
  float ty() const;
  void set_ty(float value);
  private:
  float _internal_ty() const;
  void _internal_set_ty(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.Transform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float a_;
  float b_;
  float c_;
  float d_;
  float tx_;
  float ty_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeArgs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeArgs) */ {
 public:
  inline ShapeEntity_ShapeArgs() : ShapeEntity_ShapeArgs(nullptr) {}
  virtual ~ShapeEntity_ShapeArgs();

  ShapeEntity_ShapeArgs(const ShapeEntity_ShapeArgs& from);
  ShapeEntity_ShapeArgs(ShapeEntity_ShapeArgs&& from) noexcept
    : ShapeEntity_ShapeArgs() {
    *this = ::std::move(from);
  }

  inline ShapeEntity_ShapeArgs& operator=(const ShapeEntity_ShapeArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity_ShapeArgs& operator=(ShapeEntity_ShapeArgs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity_ShapeArgs& default_instance();

  static inline const ShapeEntity_ShapeArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeArgs*>(
               &_ShapeEntity_ShapeArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShapeEntity_ShapeArgs& a, ShapeEntity_ShapeArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity_ShapeArgs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity_ShapeArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeArgs* New() const final {
    return CreateMaybeMessage<ShapeEntity_ShapeArgs>(nullptr);
  }

  ShapeEntity_ShapeArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity_ShapeArgs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity_ShapeArgs& from);
  void MergeFrom(const ShapeEntity_ShapeArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity_ShapeArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity.ShapeArgs";
  }
  protected:
  explicit ShapeEntity_ShapeArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDFieldNumber = 1,
  };
  // string d = 1;
  void clear_d();
  const std::string& d() const;
  void set_d(const std::string& value);
  void set_d(std::string&& value);
  void set_d(const char* value);
  void set_d(const char* value, size_t size);
  std::string* mutable_d();
  std::string* release_d();
  void set_allocated_d(std::string* d);
  private:
  const std::string& _internal_d() const;
  void _internal_set_d(const std::string& value);
  std::string* _internal_mutable_d();
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr d_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity_RectArgs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.RectArgs) */ {
 public:
  inline ShapeEntity_RectArgs() : ShapeEntity_RectArgs(nullptr) {}
  virtual ~ShapeEntity_RectArgs();

  ShapeEntity_RectArgs(const ShapeEntity_RectArgs& from);
  ShapeEntity_RectArgs(ShapeEntity_RectArgs&& from) noexcept
    : ShapeEntity_RectArgs() {
    *this = ::std::move(from);
  }

  inline ShapeEntity_RectArgs& operator=(const ShapeEntity_RectArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity_RectArgs& operator=(ShapeEntity_RectArgs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity_RectArgs& default_instance();

  static inline const ShapeEntity_RectArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_RectArgs*>(
               &_ShapeEntity_RectArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ShapeEntity_RectArgs& a, ShapeEntity_RectArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity_RectArgs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity_RectArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity_RectArgs* New() const final {
    return CreateMaybeMessage<ShapeEntity_RectArgs>(nullptr);
  }

  ShapeEntity_RectArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity_RectArgs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity_RectArgs& from);
  void MergeFrom(const ShapeEntity_RectArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity_RectArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity.RectArgs";
  }
  protected:
  explicit ShapeEntity_RectArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kCornerRadiusFieldNumber = 5,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float cornerRadius = 5;
  void clear_cornerradius();
  float cornerradius() const;
  void set_cornerradius(float value);
  private:
  float _internal_cornerradius() const;
  void _internal_set_cornerradius(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.RectArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float width_;
  float height_;
  float cornerradius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity_EllipseArgs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.EllipseArgs) */ {
 public:
  inline ShapeEntity_EllipseArgs() : ShapeEntity_EllipseArgs(nullptr) {}
  virtual ~ShapeEntity_EllipseArgs();

  ShapeEntity_EllipseArgs(const ShapeEntity_EllipseArgs& from);
  ShapeEntity_EllipseArgs(ShapeEntity_EllipseArgs&& from) noexcept
    : ShapeEntity_EllipseArgs() {
    *this = ::std::move(from);
  }

  inline ShapeEntity_EllipseArgs& operator=(const ShapeEntity_EllipseArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity_EllipseArgs& operator=(ShapeEntity_EllipseArgs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity_EllipseArgs& default_instance();

  static inline const ShapeEntity_EllipseArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_EllipseArgs*>(
               &_ShapeEntity_EllipseArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ShapeEntity_EllipseArgs& a, ShapeEntity_EllipseArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity_EllipseArgs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity_EllipseArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity_EllipseArgs* New() const final {
    return CreateMaybeMessage<ShapeEntity_EllipseArgs>(nullptr);
  }

  ShapeEntity_EllipseArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity_EllipseArgs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity_EllipseArgs& from);
  void MergeFrom(const ShapeEntity_EllipseArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity_EllipseArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity.EllipseArgs";
  }
  protected:
  explicit ShapeEntity_EllipseArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kRadiusXFieldNumber = 3,
    kRadiusYFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float radiusX = 3;
  void clear_radiusx();
  float radiusx() const;
  void set_radiusx(float value);
  private:
  float _internal_radiusx() const;
  void _internal_set_radiusx(float value);
  public:

  // float radiusY = 4;
  void clear_radiusy();
  float radiusy() const;
  void set_radiusy(float value);
  private:
  float _internal_radiusy() const;
  void _internal_set_radiusy(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.EllipseArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float radiusx_;
  float radiusy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeStyle_RGBAColor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor) */ {
 public:
  inline ShapeEntity_ShapeStyle_RGBAColor() : ShapeEntity_ShapeStyle_RGBAColor(nullptr) {}
  virtual ~ShapeEntity_ShapeStyle_RGBAColor();

  ShapeEntity_ShapeStyle_RGBAColor(const ShapeEntity_ShapeStyle_RGBAColor& from);
  ShapeEntity_ShapeStyle_RGBAColor(ShapeEntity_ShapeStyle_RGBAColor&& from) noexcept
    : ShapeEntity_ShapeStyle_RGBAColor() {
    *this = ::std::move(from);
  }

  inline ShapeEntity_ShapeStyle_RGBAColor& operator=(const ShapeEntity_ShapeStyle_RGBAColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity_ShapeStyle_RGBAColor& operator=(ShapeEntity_ShapeStyle_RGBAColor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity_ShapeStyle_RGBAColor& default_instance();

  static inline const ShapeEntity_ShapeStyle_RGBAColor* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeStyle_RGBAColor*>(
               &_ShapeEntity_ShapeStyle_RGBAColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ShapeEntity_ShapeStyle_RGBAColor& a, ShapeEntity_ShapeStyle_RGBAColor& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity_ShapeStyle_RGBAColor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity_ShapeStyle_RGBAColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeStyle_RGBAColor* New() const final {
    return CreateMaybeMessage<ShapeEntity_ShapeStyle_RGBAColor>(nullptr);
  }

  ShapeEntity_ShapeStyle_RGBAColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity_ShapeStyle_RGBAColor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity_ShapeStyle_RGBAColor& from);
  void MergeFrom(const ShapeEntity_ShapeStyle_RGBAColor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity_ShapeStyle_RGBAColor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor";
  }
  protected:
  explicit ShapeEntity_ShapeStyle_RGBAColor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // float r = 1;
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float g = 2;
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // float b = 3;
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // float a = 4;
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeStyle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeStyle) */ {
 public:
  inline ShapeEntity_ShapeStyle() : ShapeEntity_ShapeStyle(nullptr) {}
  virtual ~ShapeEntity_ShapeStyle();

  ShapeEntity_ShapeStyle(const ShapeEntity_ShapeStyle& from);
  ShapeEntity_ShapeStyle(ShapeEntity_ShapeStyle&& from) noexcept
    : ShapeEntity_ShapeStyle() {
    *this = ::std::move(from);
  }

  inline ShapeEntity_ShapeStyle& operator=(const ShapeEntity_ShapeStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity_ShapeStyle& operator=(ShapeEntity_ShapeStyle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity_ShapeStyle& default_instance();

  static inline const ShapeEntity_ShapeStyle* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeStyle*>(
               &_ShapeEntity_ShapeStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ShapeEntity_ShapeStyle& a, ShapeEntity_ShapeStyle& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity_ShapeStyle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity_ShapeStyle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeStyle* New() const final {
    return CreateMaybeMessage<ShapeEntity_ShapeStyle>(nullptr);
  }

  ShapeEntity_ShapeStyle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity_ShapeStyle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity_ShapeStyle& from);
  void MergeFrom(const ShapeEntity_ShapeStyle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity_ShapeStyle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity.ShapeStyle";
  }
  protected:
  explicit ShapeEntity_ShapeStyle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ShapeEntity_ShapeStyle_RGBAColor RGBAColor;

  typedef ShapeEntity_ShapeStyle_LineCap LineCap;
  static constexpr LineCap LineCap_BUTT =
    ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT;
  static constexpr LineCap LineCap_ROUND =
    ShapeEntity_ShapeStyle_LineCap_LineCap_ROUND;
  static constexpr LineCap LineCap_SQUARE =
    ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE;
  static inline bool LineCap_IsValid(int value) {
    return ShapeEntity_ShapeStyle_LineCap_IsValid(value);
  }
  static constexpr LineCap LineCap_MIN =
    ShapeEntity_ShapeStyle_LineCap_LineCap_MIN;
  static constexpr LineCap LineCap_MAX =
    ShapeEntity_ShapeStyle_LineCap_LineCap_MAX;
  static constexpr int LineCap_ARRAYSIZE =
    ShapeEntity_ShapeStyle_LineCap_LineCap_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineCap_descriptor() {
    return ShapeEntity_ShapeStyle_LineCap_descriptor();
  }
  template<typename T>
  static inline const std::string& LineCap_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineCap>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineCap_Name.");
    return ShapeEntity_ShapeStyle_LineCap_Name(enum_t_value);
  }
  static inline bool LineCap_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LineCap* value) {
    return ShapeEntity_ShapeStyle_LineCap_Parse(name, value);
  }

  typedef ShapeEntity_ShapeStyle_LineJoin LineJoin;
  static constexpr LineJoin LineJoin_MITER =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER;
  static constexpr LineJoin LineJoin_ROUND =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_ROUND;
  static constexpr LineJoin LineJoin_BEVEL =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL;
  static inline bool LineJoin_IsValid(int value) {
    return ShapeEntity_ShapeStyle_LineJoin_IsValid(value);
  }
  static constexpr LineJoin LineJoin_MIN =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MIN;
  static constexpr LineJoin LineJoin_MAX =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX;
  static constexpr int LineJoin_ARRAYSIZE =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineJoin_descriptor() {
    return ShapeEntity_ShapeStyle_LineJoin_descriptor();
  }
  template<typename T>
  static inline const std::string& LineJoin_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineJoin>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineJoin_Name.");
    return ShapeEntity_ShapeStyle_LineJoin_Name(enum_t_value);
  }
  static inline bool LineJoin_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LineJoin* value) {
    return ShapeEntity_ShapeStyle_LineJoin_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFillFieldNumber = 1,
    kStrokeFieldNumber = 2,
    kStrokeWidthFieldNumber = 3,
    kLineCapFieldNumber = 4,
    kLineJoinFieldNumber = 5,
    kMiterLimitFieldNumber = 6,
    kLineDashIFieldNumber = 7,
    kLineDashIIFieldNumber = 8,
    kLineDashIIIFieldNumber = 9,
  };
  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& fill() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* release_fill();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* mutable_fill();
  void set_allocated_fill(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill);
  private:
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& _internal_fill() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill);
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* unsafe_arena_release_fill();

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& stroke() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* release_stroke();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* mutable_stroke();
  void set_allocated_stroke(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke);
  private:
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& _internal_stroke() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke);
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* unsafe_arena_release_stroke();

  // float strokeWidth = 3;
  void clear_strokewidth();
  float strokewidth() const;
  void set_strokewidth(float value);
  private:
  float _internal_strokewidth() const;
  void _internal_set_strokewidth(float value);
  public:

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
  void clear_linecap();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap linecap() const;
  void set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value);
  private:
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap _internal_linecap() const;
  void _internal_set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value);
  public:

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
  void clear_linejoin();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin linejoin() const;
  void set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value);
  private:
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin _internal_linejoin() const;
  void _internal_set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value);
  public:

  // float miterLimit = 6;
  void clear_miterlimit();
  float miterlimit() const;
  void set_miterlimit(float value);
  private:
  float _internal_miterlimit() const;
  void _internal_set_miterlimit(float value);
  public:

  // float lineDashI = 7;
  void clear_linedashi();
  float linedashi() const;
  void set_linedashi(float value);
  private:
  float _internal_linedashi() const;
  void _internal_set_linedashi(float value);
  public:

  // float lineDashII = 8;
  void clear_linedashii();
  float linedashii() const;
  void set_linedashii(float value);
  private:
  float _internal_linedashii() const;
  void _internal_set_linedashii(float value);
  public:

  // float lineDashIII = 9;
  void clear_linedashiii();
  float linedashiii() const;
  void set_linedashiii(float value);
  private:
  float _internal_linedashiii() const;
  void _internal_set_linedashiii(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeStyle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke_;
  float strokewidth_;
  int linecap_;
  int linejoin_;
  float miterlimit_;
  float linedashi_;
  float linedashii_;
  float linedashiii_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class ShapeEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity) */ {
 public:
  inline ShapeEntity() : ShapeEntity(nullptr) {}
  virtual ~ShapeEntity();

  ShapeEntity(const ShapeEntity& from);
  ShapeEntity(ShapeEntity&& from) noexcept
    : ShapeEntity() {
    *this = ::std::move(from);
  }

  inline ShapeEntity& operator=(const ShapeEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeEntity& operator=(ShapeEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShapeEntity& default_instance();

  enum ArgsCase {
    kShape = 2,
    kRect = 3,
    kEllipse = 4,
    ARGS_NOT_SET = 0,
  };

  static inline const ShapeEntity* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity*>(
               &_ShapeEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ShapeEntity& a, ShapeEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShapeEntity* New() const final {
    return CreateMaybeMessage<ShapeEntity>(nullptr);
  }

  ShapeEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShapeEntity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShapeEntity& from);
  void MergeFrom(const ShapeEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.ShapeEntity";
  }
  protected:
  explicit ShapeEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ShapeEntity_ShapeArgs ShapeArgs;
  typedef ShapeEntity_RectArgs RectArgs;
  typedef ShapeEntity_EllipseArgs EllipseArgs;
  typedef ShapeEntity_ShapeStyle ShapeStyle;

  typedef ShapeEntity_ShapeType ShapeType;
  static constexpr ShapeType SHAPE =
    ShapeEntity_ShapeType_SHAPE;
  static constexpr ShapeType RECT =
    ShapeEntity_ShapeType_RECT;
  static constexpr ShapeType ELLIPSE =
    ShapeEntity_ShapeType_ELLIPSE;
  static constexpr ShapeType KEEP =
    ShapeEntity_ShapeType_KEEP;
  static inline bool ShapeType_IsValid(int value) {
    return ShapeEntity_ShapeType_IsValid(value);
  }
  static constexpr ShapeType ShapeType_MIN =
    ShapeEntity_ShapeType_ShapeType_MIN;
  static constexpr ShapeType ShapeType_MAX =
    ShapeEntity_ShapeType_ShapeType_MAX;
  static constexpr int ShapeType_ARRAYSIZE =
    ShapeEntity_ShapeType_ShapeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShapeType_descriptor() {
    return ShapeEntity_ShapeType_descriptor();
  }
  template<typename T>
  static inline const std::string& ShapeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShapeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShapeType_Name.");
    return ShapeEntity_ShapeType_Name(enum_t_value);
  }
  static inline bool ShapeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShapeType* value) {
    return ShapeEntity_ShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStylesFieldNumber = 10,
    kTransformFieldNumber = 11,
    kTypeFieldNumber = 1,
    kShapeFieldNumber = 2,
    kRectFieldNumber = 3,
    kEllipseFieldNumber = 4,
  };
  // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
  bool has_styles() const;
  private:
  bool _internal_has_styles() const;
  public:
  void clear_styles();
  const ::com::opensource::svga::ShapeEntity_ShapeStyle& styles() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle* release_styles();
  ::com::opensource::svga::ShapeEntity_ShapeStyle* mutable_styles();
  void set_allocated_styles(::com::opensource::svga::ShapeEntity_ShapeStyle* styles);
  private:
  const ::com::opensource::svga::ShapeEntity_ShapeStyle& _internal_styles() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle* _internal_mutable_styles();
  public:
  void unsafe_arena_set_allocated_styles(
      ::com::opensource::svga::ShapeEntity_ShapeStyle* styles);
  ::com::opensource::svga::ShapeEntity_ShapeStyle* unsafe_arena_release_styles();

  // .com.opensource.svga.Transform transform = 11;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::com::opensource::svga::Transform& transform() const;
  ::com::opensource::svga::Transform* release_transform();
  ::com::opensource::svga::Transform* mutable_transform();
  void set_allocated_transform(::com::opensource::svga::Transform* transform);
  private:
  const ::com::opensource::svga::Transform& _internal_transform() const;
  ::com::opensource::svga::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::com::opensource::svga::Transform* transform);
  ::com::opensource::svga::Transform* unsafe_arena_release_transform();

  // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
  void clear_type();
  ::com::opensource::svga::ShapeEntity_ShapeType type() const;
  void set_type(::com::opensource::svga::ShapeEntity_ShapeType value);
  private:
  ::com::opensource::svga::ShapeEntity_ShapeType _internal_type() const;
  void _internal_set_type(::com::opensource::svga::ShapeEntity_ShapeType value);
  public:

  // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::com::opensource::svga::ShapeEntity_ShapeArgs& shape() const;
  ::com::opensource::svga::ShapeEntity_ShapeArgs* release_shape();
  ::com::opensource::svga::ShapeEntity_ShapeArgs* mutable_shape();
  void set_allocated_shape(::com::opensource::svga::ShapeEntity_ShapeArgs* shape);
  private:
  const ::com::opensource::svga::ShapeEntity_ShapeArgs& _internal_shape() const;
  ::com::opensource::svga::ShapeEntity_ShapeArgs* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::com::opensource::svga::ShapeEntity_ShapeArgs* shape);
  ::com::opensource::svga::ShapeEntity_ShapeArgs* unsafe_arena_release_shape();

  // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
  bool has_rect() const;
  private:
  bool _internal_has_rect() const;
  public:
  void clear_rect();
  const ::com::opensource::svga::ShapeEntity_RectArgs& rect() const;
  ::com::opensource::svga::ShapeEntity_RectArgs* release_rect();
  ::com::opensource::svga::ShapeEntity_RectArgs* mutable_rect();
  void set_allocated_rect(::com::opensource::svga::ShapeEntity_RectArgs* rect);
  private:
  const ::com::opensource::svga::ShapeEntity_RectArgs& _internal_rect() const;
  ::com::opensource::svga::ShapeEntity_RectArgs* _internal_mutable_rect();
  public:
  void unsafe_arena_set_allocated_rect(
      ::com::opensource::svga::ShapeEntity_RectArgs* rect);
  ::com::opensource::svga::ShapeEntity_RectArgs* unsafe_arena_release_rect();

  // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
  bool has_ellipse() const;
  private:
  bool _internal_has_ellipse() const;
  public:
  void clear_ellipse();
  const ::com::opensource::svga::ShapeEntity_EllipseArgs& ellipse() const;
  ::com::opensource::svga::ShapeEntity_EllipseArgs* release_ellipse();
  ::com::opensource::svga::ShapeEntity_EllipseArgs* mutable_ellipse();
  void set_allocated_ellipse(::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse);
  private:
  const ::com::opensource::svga::ShapeEntity_EllipseArgs& _internal_ellipse() const;
  ::com::opensource::svga::ShapeEntity_EllipseArgs* _internal_mutable_ellipse();
  public:
  void unsafe_arena_set_allocated_ellipse(
      ::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse);
  ::com::opensource::svga::ShapeEntity_EllipseArgs* unsafe_arena_release_ellipse();

  void clear_args();
  ArgsCase args_case() const;
  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity)
 private:
  class _Internal;
  void set_has_shape();
  void set_has_rect();
  void set_has_ellipse();

  inline bool has_args() const;
  inline void clear_has_args();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle* styles_;
  ::com::opensource::svga::Transform* transform_;
  int type_;
  union ArgsUnion {
    ArgsUnion() {}
    ::com::opensource::svga::ShapeEntity_ShapeArgs* shape_;
    ::com::opensource::svga::ShapeEntity_RectArgs* rect_;
    ::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse_;
  } args_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class FrameEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.FrameEntity) */ {
 public:
  inline FrameEntity() : FrameEntity(nullptr) {}
  virtual ~FrameEntity();

  FrameEntity(const FrameEntity& from);
  FrameEntity(FrameEntity&& from) noexcept
    : FrameEntity() {
    *this = ::std::move(from);
  }

  inline FrameEntity& operator=(const FrameEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameEntity& operator=(FrameEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameEntity& default_instance();

  static inline const FrameEntity* internal_default_instance() {
    return reinterpret_cast<const FrameEntity*>(
               &_FrameEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FrameEntity& a, FrameEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameEntity* New() const final {
    return CreateMaybeMessage<FrameEntity>(nullptr);
  }

  FrameEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameEntity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameEntity& from);
  void MergeFrom(const FrameEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.FrameEntity";
  }
  protected:
  explicit FrameEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 5,
    kClipPathFieldNumber = 4,
    kLayoutFieldNumber = 2,
    kTransformFieldNumber = 3,
    kAlphaFieldNumber = 1,
  };
  // repeated .com.opensource.svga.ShapeEntity shapes = 5;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::com::opensource::svga::ShapeEntity* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >*
      mutable_shapes();
  private:
  const ::com::opensource::svga::ShapeEntity& _internal_shapes(int index) const;
  ::com::opensource::svga::ShapeEntity* _internal_add_shapes();
  public:
  const ::com::opensource::svga::ShapeEntity& shapes(int index) const;
  ::com::opensource::svga::ShapeEntity* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >&
      shapes() const;

  // string clipPath = 4;
  void clear_clippath();
  const std::string& clippath() const;
  void set_clippath(const std::string& value);
  void set_clippath(std::string&& value);
  void set_clippath(const char* value);
  void set_clippath(const char* value, size_t size);
  std::string* mutable_clippath();
  std::string* release_clippath();
  void set_allocated_clippath(std::string* clippath);
  private:
  const std::string& _internal_clippath() const;
  void _internal_set_clippath(const std::string& value);
  std::string* _internal_mutable_clippath();
  public:

  // .com.opensource.svga.Layout layout = 2;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const ::com::opensource::svga::Layout& layout() const;
  ::com::opensource::svga::Layout* release_layout();
  ::com::opensource::svga::Layout* mutable_layout();
  void set_allocated_layout(::com::opensource::svga::Layout* layout);
  private:
  const ::com::opensource::svga::Layout& _internal_layout() const;
  ::com::opensource::svga::Layout* _internal_mutable_layout();
  public:
  void unsafe_arena_set_allocated_layout(
      ::com::opensource::svga::Layout* layout);
  ::com::opensource::svga::Layout* unsafe_arena_release_layout();

  // .com.opensource.svga.Transform transform = 3;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::com::opensource::svga::Transform& transform() const;
  ::com::opensource::svga::Transform* release_transform();
  ::com::opensource::svga::Transform* mutable_transform();
  void set_allocated_transform(::com::opensource::svga::Transform* transform);
  private:
  const ::com::opensource::svga::Transform& _internal_transform() const;
  ::com::opensource::svga::Transform* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::com::opensource::svga::Transform* transform);
  ::com::opensource::svga::Transform* unsafe_arena_release_transform();

  // float alpha = 1;
  void clear_alpha();
  float alpha() const;
  void set_alpha(float value);
  private:
  float _internal_alpha() const;
  void _internal_set_alpha(float value);
  public:

  // @@protoc_insertion_point(class_scope:com.opensource.svga.FrameEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::ShapeEntity > shapes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clippath_;
  ::com::opensource::svga::Layout* layout_;
  ::com::opensource::svga::Transform* transform_;
  float alpha_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// -------------------------------------------------------------------

class MovieEntity_ImagesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MovieEntity_ImagesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MovieEntity_ImagesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  MovieEntity_ImagesEntry_DoNotUse();
  explicit MovieEntity_ImagesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MovieEntity_ImagesEntry_DoNotUse& other);
  static const MovieEntity_ImagesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MovieEntity_ImagesEntry_DoNotUse*>(&_MovieEntity_ImagesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "com.opensource.svga.MovieEntity.ImagesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[12];
  }

  public:
};

// -------------------------------------------------------------------

class MovieEntity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.MovieEntity) */ {
 public:
  inline MovieEntity() : MovieEntity(nullptr) {}
  virtual ~MovieEntity();

  MovieEntity(const MovieEntity& from);
  MovieEntity(MovieEntity&& from) noexcept
    : MovieEntity() {
    *this = ::std::move(from);
  }

  inline MovieEntity& operator=(const MovieEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieEntity& operator=(MovieEntity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MovieEntity& default_instance();

  static inline const MovieEntity* internal_default_instance() {
    return reinterpret_cast<const MovieEntity*>(
               &_MovieEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MovieEntity& a, MovieEntity& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieEntity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieEntity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovieEntity* New() const final {
    return CreateMaybeMessage<MovieEntity>(nullptr);
  }

  MovieEntity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovieEntity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovieEntity& from);
  void MergeFrom(const MovieEntity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieEntity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.opensource.svga.MovieEntity";
  }
  protected:
  explicit MovieEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_svga_2eproto);
    return ::descriptor_table_svga_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 3,
    kSpritesFieldNumber = 4,
    kAudiosFieldNumber = 5,
    kVersionFieldNumber = 1,
    kParamsFieldNumber = 2,
  };
  // map<string, bytes> images = 3;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_images() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_images();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      images() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_images();

  // repeated .com.opensource.svga.SpriteEntity sprites = 4;
  int sprites_size() const;
  private:
  int _internal_sprites_size() const;
  public:
  void clear_sprites();
  ::com::opensource::svga::SpriteEntity* mutable_sprites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >*
      mutable_sprites();
  private:
  const ::com::opensource::svga::SpriteEntity& _internal_sprites(int index) const;
  ::com::opensource::svga::SpriteEntity* _internal_add_sprites();
  public:
  const ::com::opensource::svga::SpriteEntity& sprites(int index) const;
  ::com::opensource::svga::SpriteEntity* add_sprites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >&
      sprites() const;

  // repeated .com.opensource.svga.AudioEntity audios = 5;
  int audios_size() const;
  private:
  int _internal_audios_size() const;
  public:
  void clear_audios();
  ::com::opensource::svga::AudioEntity* mutable_audios(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::AudioEntity >*
      mutable_audios();
  private:
  const ::com::opensource::svga::AudioEntity& _internal_audios(int index) const;
  ::com::opensource::svga::AudioEntity* _internal_add_audios();
  public:
  const ::com::opensource::svga::AudioEntity& audios(int index) const;
  ::com::opensource::svga::AudioEntity* add_audios();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::AudioEntity >&
      audios() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .com.opensource.svga.MovieParams params = 2;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::com::opensource::svga::MovieParams& params() const;
  ::com::opensource::svga::MovieParams* release_params();
  ::com::opensource::svga::MovieParams* mutable_params();
  void set_allocated_params(::com::opensource::svga::MovieParams* params);
  private:
  const ::com::opensource::svga::MovieParams& _internal_params() const;
  ::com::opensource::svga::MovieParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::com::opensource::svga::MovieParams* params);
  ::com::opensource::svga::MovieParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:com.opensource.svga.MovieEntity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MovieEntity_ImagesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> images_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::SpriteEntity > sprites_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::AudioEntity > audios_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::com::opensource::svga::MovieParams* params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svga_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MovieParams

// float viewBoxWidth = 1;
inline void MovieParams::clear_viewboxwidth() {
  viewboxwidth_ = 0;
}
inline float MovieParams::_internal_viewboxwidth() const {
  return viewboxwidth_;
}
inline float MovieParams::viewboxwidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxWidth)
  return _internal_viewboxwidth();
}
inline void MovieParams::_internal_set_viewboxwidth(float value) {
  
  viewboxwidth_ = value;
}
inline void MovieParams::set_viewboxwidth(float value) {
  _internal_set_viewboxwidth(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxWidth)
}

// float viewBoxHeight = 2;
inline void MovieParams::clear_viewboxheight() {
  viewboxheight_ = 0;
}
inline float MovieParams::_internal_viewboxheight() const {
  return viewboxheight_;
}
inline float MovieParams::viewboxheight() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxHeight)
  return _internal_viewboxheight();
}
inline void MovieParams::_internal_set_viewboxheight(float value) {
  
  viewboxheight_ = value;
}
inline void MovieParams::set_viewboxheight(float value) {
  _internal_set_viewboxheight(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxHeight)
}

// int32 fps = 3;
inline void MovieParams::clear_fps() {
  fps_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieParams::_internal_fps() const {
  return fps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieParams::fps() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.fps)
  return _internal_fps();
}
inline void MovieParams::_internal_set_fps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fps_ = value;
}
inline void MovieParams::set_fps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.fps)
}

// int32 frames = 4;
inline void MovieParams::clear_frames() {
  frames_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieParams::_internal_frames() const {
  return frames_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MovieParams::frames() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.frames)
  return _internal_frames();
}
inline void MovieParams::_internal_set_frames(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  frames_ = value;
}
inline void MovieParams::set_frames(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_frames(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.frames)
}

// -------------------------------------------------------------------

// SpriteEntity

// string imageKey = 1;
inline void SpriteEntity::clear_imagekey() {
  imagekey_.ClearToEmpty();
}
inline const std::string& SpriteEntity::imagekey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.imageKey)
  return _internal_imagekey();
}
inline void SpriteEntity::set_imagekey(const std::string& value) {
  _internal_set_imagekey(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.SpriteEntity.imageKey)
}
inline std::string* SpriteEntity::mutable_imagekey() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.imageKey)
  return _internal_mutable_imagekey();
}
inline const std::string& SpriteEntity::_internal_imagekey() const {
  return imagekey_.Get();
}
inline void SpriteEntity::_internal_set_imagekey(const std::string& value) {
  
  imagekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SpriteEntity::set_imagekey(std::string&& value) {
  
  imagekey_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.SpriteEntity.imageKey)
}
inline void SpriteEntity::set_imagekey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  imagekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.SpriteEntity.imageKey)
}
inline void SpriteEntity::set_imagekey(const char* value,
    size_t size) {
  
  imagekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.SpriteEntity.imageKey)
}
inline std::string* SpriteEntity::_internal_mutable_imagekey() {
  
  return imagekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SpriteEntity::release_imagekey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.SpriteEntity.imageKey)
  return imagekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpriteEntity::set_allocated_imagekey(std::string* imagekey) {
  if (imagekey != nullptr) {
    
  } else {
    
  }
  imagekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imagekey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.SpriteEntity.imageKey)
}

// repeated .com.opensource.svga.FrameEntity frames = 2;
inline int SpriteEntity::_internal_frames_size() const {
  return frames_.size();
}
inline int SpriteEntity::frames_size() const {
  return _internal_frames_size();
}
inline void SpriteEntity::clear_frames() {
  frames_.Clear();
}
inline ::com::opensource::svga::FrameEntity* SpriteEntity::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::FrameEntity >*
SpriteEntity::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.SpriteEntity.frames)
  return &frames_;
}
inline const ::com::opensource::svga::FrameEntity& SpriteEntity::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::com::opensource::svga::FrameEntity& SpriteEntity::frames(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.frames)
  return _internal_frames(index);
}
inline ::com::opensource::svga::FrameEntity* SpriteEntity::_internal_add_frames() {
  return frames_.Add();
}
inline ::com::opensource::svga::FrameEntity* SpriteEntity::add_frames() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.SpriteEntity.frames)
  return _internal_add_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::FrameEntity >&
SpriteEntity::frames() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.SpriteEntity.frames)
  return frames_;
}

// string matteKey = 3;
inline void SpriteEntity::clear_mattekey() {
  mattekey_.ClearToEmpty();
}
inline const std::string& SpriteEntity::mattekey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.matteKey)
  return _internal_mattekey();
}
inline void SpriteEntity::set_mattekey(const std::string& value) {
  _internal_set_mattekey(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.SpriteEntity.matteKey)
}
inline std::string* SpriteEntity::mutable_mattekey() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.matteKey)
  return _internal_mutable_mattekey();
}
inline const std::string& SpriteEntity::_internal_mattekey() const {
  return mattekey_.Get();
}
inline void SpriteEntity::_internal_set_mattekey(const std::string& value) {
  
  mattekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SpriteEntity::set_mattekey(std::string&& value) {
  
  mattekey_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.SpriteEntity.matteKey)
}
inline void SpriteEntity::set_mattekey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mattekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.SpriteEntity.matteKey)
}
inline void SpriteEntity::set_mattekey(const char* value,
    size_t size) {
  
  mattekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.SpriteEntity.matteKey)
}
inline std::string* SpriteEntity::_internal_mutable_mattekey() {
  
  return mattekey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SpriteEntity::release_mattekey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.SpriteEntity.matteKey)
  return mattekey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpriteEntity::set_allocated_mattekey(std::string* mattekey) {
  if (mattekey != nullptr) {
    
  } else {
    
  }
  mattekey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mattekey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.SpriteEntity.matteKey)
}

// -------------------------------------------------------------------

// AudioEntity

// string audioKey = 1;
inline void AudioEntity::clear_audiokey() {
  audiokey_.ClearToEmpty();
}
inline const std::string& AudioEntity::audiokey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.audioKey)
  return _internal_audiokey();
}
inline void AudioEntity::set_audiokey(const std::string& value) {
  _internal_set_audiokey(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.audioKey)
}
inline std::string* AudioEntity::mutable_audiokey() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.AudioEntity.audioKey)
  return _internal_mutable_audiokey();
}
inline const std::string& AudioEntity::_internal_audiokey() const {
  return audiokey_.Get();
}
inline void AudioEntity::_internal_set_audiokey(const std::string& value) {
  
  audiokey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AudioEntity::set_audiokey(std::string&& value) {
  
  audiokey_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.AudioEntity.audioKey)
}
inline void AudioEntity::set_audiokey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  audiokey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.AudioEntity.audioKey)
}
inline void AudioEntity::set_audiokey(const char* value,
    size_t size) {
  
  audiokey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.AudioEntity.audioKey)
}
inline std::string* AudioEntity::_internal_mutable_audiokey() {
  
  return audiokey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AudioEntity::release_audiokey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.AudioEntity.audioKey)
  return audiokey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioEntity::set_allocated_audiokey(std::string* audiokey) {
  if (audiokey != nullptr) {
    
  } else {
    
  }
  audiokey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audiokey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.AudioEntity.audioKey)
}

// int32 startFrame = 2;
inline void AudioEntity::clear_startframe() {
  startframe_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::_internal_startframe() const {
  return startframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::startframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startFrame)
  return _internal_startframe();
}
inline void AudioEntity::_internal_set_startframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  startframe_ = value;
}
inline void AudioEntity::set_startframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_startframe(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startFrame)
}

// int32 endFrame = 3;
inline void AudioEntity::clear_endframe() {
  endframe_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::_internal_endframe() const {
  return endframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::endframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.endFrame)
  return _internal_endframe();
}
inline void AudioEntity::_internal_set_endframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  endframe_ = value;
}
inline void AudioEntity::set_endframe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_endframe(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.endFrame)
}

// int32 startTime = 4;
inline void AudioEntity::clear_starttime() {
  starttime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::_internal_starttime() const {
  return starttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::starttime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startTime)
  return _internal_starttime();
}
inline void AudioEntity::_internal_set_starttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  starttime_ = value;
}
inline void AudioEntity::set_starttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startTime)
}

// int32 totalTime = 5;
inline void AudioEntity::clear_totaltime() {
  totaltime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::_internal_totaltime() const {
  return totaltime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioEntity::totaltime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.totalTime)
  return _internal_totaltime();
}
inline void AudioEntity::_internal_set_totaltime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  totaltime_ = value;
}
inline void AudioEntity::set_totaltime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_totaltime(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.totalTime)
}

// -------------------------------------------------------------------

// Layout

// float x = 1;
inline void Layout::clear_x() {
  x_ = 0;
}
inline float Layout::_internal_x() const {
  return x_;
}
inline float Layout::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.x)
  return _internal_x();
}
inline void Layout::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Layout::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.x)
}

// float y = 2;
inline void Layout::clear_y() {
  y_ = 0;
}
inline float Layout::_internal_y() const {
  return y_;
}
inline float Layout::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.y)
  return _internal_y();
}
inline void Layout::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Layout::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.y)
}

// float width = 3;
inline void Layout::clear_width() {
  width_ = 0;
}
inline float Layout::_internal_width() const {
  return width_;
}
inline float Layout::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.width)
  return _internal_width();
}
inline void Layout::_internal_set_width(float value) {
  
  width_ = value;
}
inline void Layout::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.width)
}

// float height = 4;
inline void Layout::clear_height() {
  height_ = 0;
}
inline float Layout::_internal_height() const {
  return height_;
}
inline float Layout::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.height)
  return _internal_height();
}
inline void Layout::_internal_set_height(float value) {
  
  height_ = value;
}
inline void Layout::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.height)
}

// -------------------------------------------------------------------

// Transform

// float a = 1;
inline void Transform::clear_a() {
  a_ = 0;
}
inline float Transform::_internal_a() const {
  return a_;
}
inline float Transform::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.a)
  return _internal_a();
}
inline void Transform::_internal_set_a(float value) {
  
  a_ = value;
}
inline void Transform::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.a)
}

// float b = 2;
inline void Transform::clear_b() {
  b_ = 0;
}
inline float Transform::_internal_b() const {
  return b_;
}
inline float Transform::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.b)
  return _internal_b();
}
inline void Transform::_internal_set_b(float value) {
  
  b_ = value;
}
inline void Transform::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.b)
}

// float c = 3;
inline void Transform::clear_c() {
  c_ = 0;
}
inline float Transform::_internal_c() const {
  return c_;
}
inline float Transform::c() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.c)
  return _internal_c();
}
inline void Transform::_internal_set_c(float value) {
  
  c_ = value;
}
inline void Transform::set_c(float value) {
  _internal_set_c(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.c)
}

// float d = 4;
inline void Transform::clear_d() {
  d_ = 0;
}
inline float Transform::_internal_d() const {
  return d_;
}
inline float Transform::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.d)
  return _internal_d();
}
inline void Transform::_internal_set_d(float value) {
  
  d_ = value;
}
inline void Transform::set_d(float value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.d)
}

// float tx = 5;
inline void Transform::clear_tx() {
  tx_ = 0;
}
inline float Transform::_internal_tx() const {
  return tx_;
}
inline float Transform::tx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.tx)
  return _internal_tx();
}
inline void Transform::_internal_set_tx(float value) {
  
  tx_ = value;
}
inline void Transform::set_tx(float value) {
  _internal_set_tx(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.tx)
}

// float ty = 6;
inline void Transform::clear_ty() {
  ty_ = 0;
}
inline float Transform::_internal_ty() const {
  return ty_;
}
inline float Transform::ty() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.ty)
  return _internal_ty();
}
inline void Transform::_internal_set_ty(float value) {
  
  ty_ = value;
}
inline void Transform::set_ty(float value) {
  _internal_set_ty(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.ty)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeArgs

// string d = 1;
inline void ShapeEntity_ShapeArgs::clear_d() {
  d_.ClearToEmpty();
}
inline const std::string& ShapeEntity_ShapeArgs::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return _internal_d();
}
inline void ShapeEntity_ShapeArgs::set_d(const std::string& value) {
  _internal_set_d(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline std::string* ShapeEntity_ShapeArgs::mutable_d() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return _internal_mutable_d();
}
inline const std::string& ShapeEntity_ShapeArgs::_internal_d() const {
  return d_.Get();
}
inline void ShapeEntity_ShapeArgs::_internal_set_d(const std::string& value) {
  
  d_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ShapeEntity_ShapeArgs::set_d(std::string&& value) {
  
  d_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline void ShapeEntity_ShapeArgs::set_d(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  d_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline void ShapeEntity_ShapeArgs::set_d(const char* value,
    size_t size) {
  
  d_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline std::string* ShapeEntity_ShapeArgs::_internal_mutable_d() {
  
  return d_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ShapeEntity_ShapeArgs::release_d() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return d_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ShapeEntity_ShapeArgs::set_allocated_d(std::string* d) {
  if (d != nullptr) {
    
  } else {
    
  }
  d_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), d,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}

// -------------------------------------------------------------------

// ShapeEntity_RectArgs

// float x = 1;
inline void ShapeEntity_RectArgs::clear_x() {
  x_ = 0;
}
inline float ShapeEntity_RectArgs::_internal_x() const {
  return x_;
}
inline float ShapeEntity_RectArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.x)
  return _internal_x();
}
inline void ShapeEntity_RectArgs::_internal_set_x(float value) {
  
  x_ = value;
}
inline void ShapeEntity_RectArgs::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.x)
}

// float y = 2;
inline void ShapeEntity_RectArgs::clear_y() {
  y_ = 0;
}
inline float ShapeEntity_RectArgs::_internal_y() const {
  return y_;
}
inline float ShapeEntity_RectArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.y)
  return _internal_y();
}
inline void ShapeEntity_RectArgs::_internal_set_y(float value) {
  
  y_ = value;
}
inline void ShapeEntity_RectArgs::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.y)
}

// float width = 3;
inline void ShapeEntity_RectArgs::clear_width() {
  width_ = 0;
}
inline float ShapeEntity_RectArgs::_internal_width() const {
  return width_;
}
inline float ShapeEntity_RectArgs::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.width)
  return _internal_width();
}
inline void ShapeEntity_RectArgs::_internal_set_width(float value) {
  
  width_ = value;
}
inline void ShapeEntity_RectArgs::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.width)
}

// float height = 4;
inline void ShapeEntity_RectArgs::clear_height() {
  height_ = 0;
}
inline float ShapeEntity_RectArgs::_internal_height() const {
  return height_;
}
inline float ShapeEntity_RectArgs::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.height)
  return _internal_height();
}
inline void ShapeEntity_RectArgs::_internal_set_height(float value) {
  
  height_ = value;
}
inline void ShapeEntity_RectArgs::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.height)
}

// float cornerRadius = 5;
inline void ShapeEntity_RectArgs::clear_cornerradius() {
  cornerradius_ = 0;
}
inline float ShapeEntity_RectArgs::_internal_cornerradius() const {
  return cornerradius_;
}
inline float ShapeEntity_RectArgs::cornerradius() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
  return _internal_cornerradius();
}
inline void ShapeEntity_RectArgs::_internal_set_cornerradius(float value) {
  
  cornerradius_ = value;
}
inline void ShapeEntity_RectArgs::set_cornerradius(float value) {
  _internal_set_cornerradius(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
}

// -------------------------------------------------------------------

// ShapeEntity_EllipseArgs

// float x = 1;
inline void ShapeEntity_EllipseArgs::clear_x() {
  x_ = 0;
}
inline float ShapeEntity_EllipseArgs::_internal_x() const {
  return x_;
}
inline float ShapeEntity_EllipseArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.x)
  return _internal_x();
}
inline void ShapeEntity_EllipseArgs::_internal_set_x(float value) {
  
  x_ = value;
}
inline void ShapeEntity_EllipseArgs::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.x)
}

// float y = 2;
inline void ShapeEntity_EllipseArgs::clear_y() {
  y_ = 0;
}
inline float ShapeEntity_EllipseArgs::_internal_y() const {
  return y_;
}
inline float ShapeEntity_EllipseArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.y)
  return _internal_y();
}
inline void ShapeEntity_EllipseArgs::_internal_set_y(float value) {
  
  y_ = value;
}
inline void ShapeEntity_EllipseArgs::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.y)
}

// float radiusX = 3;
inline void ShapeEntity_EllipseArgs::clear_radiusx() {
  radiusx_ = 0;
}
inline float ShapeEntity_EllipseArgs::_internal_radiusx() const {
  return radiusx_;
}
inline float ShapeEntity_EllipseArgs::radiusx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
  return _internal_radiusx();
}
inline void ShapeEntity_EllipseArgs::_internal_set_radiusx(float value) {
  
  radiusx_ = value;
}
inline void ShapeEntity_EllipseArgs::set_radiusx(float value) {
  _internal_set_radiusx(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
}

// float radiusY = 4;
inline void ShapeEntity_EllipseArgs::clear_radiusy() {
  radiusy_ = 0;
}
inline float ShapeEntity_EllipseArgs::_internal_radiusy() const {
  return radiusy_;
}
inline float ShapeEntity_EllipseArgs::radiusy() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
  return _internal_radiusy();
}
inline void ShapeEntity_EllipseArgs::_internal_set_radiusy(float value) {
  
  radiusy_ = value;
}
inline void ShapeEntity_EllipseArgs::set_radiusy(float value) {
  _internal_set_radiusy(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeStyle_RGBAColor

// float r = 1;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_r() {
  r_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::_internal_r() const {
  return r_;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::r() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
  return _internal_r();
}
inline void ShapeEntity_ShapeStyle_RGBAColor::_internal_set_r(float value) {
  
  r_ = value;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
}

// float g = 2;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_g() {
  g_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::_internal_g() const {
  return g_;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::g() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
  return _internal_g();
}
inline void ShapeEntity_ShapeStyle_RGBAColor::_internal_set_g(float value) {
  
  g_ = value;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
}

// float b = 3;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_b() {
  b_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::_internal_b() const {
  return b_;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
  return _internal_b();
}
inline void ShapeEntity_ShapeStyle_RGBAColor::_internal_set_b(float value) {
  
  b_ = value;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
}

// float a = 4;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_a() {
  a_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::_internal_a() const {
  return a_;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
  return _internal_a();
}
inline void ShapeEntity_ShapeStyle_RGBAColor::_internal_set_a(float value) {
  
  a_ = value;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeStyle

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
inline bool ShapeEntity_ShapeStyle::_internal_has_fill() const {
  return this != internal_default_instance() && fill_ != nullptr;
}
inline bool ShapeEntity_ShapeStyle::has_fill() const {
  return _internal_has_fill();
}
inline void ShapeEntity_ShapeStyle::clear_fill() {
  if (GetArena() == nullptr && fill_ != nullptr) {
    delete fill_;
  }
  fill_ = nullptr;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::_internal_fill() const {
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* p = fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor&>(
      ::com::opensource::svga::_ShapeEntity_ShapeStyle_RGBAColor_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::fill() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return _internal_fill();
}
inline void ShapeEntity_ShapeStyle::unsafe_arena_set_allocated_fill(
    ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill_);
  }
  fill_ = fill;
  if (fill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_fill() {
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = fill_;
  fill_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = fill_;
  fill_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::_internal_mutable_fill() {
  
  if (fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor>(GetArena());
    fill_ = p;
  }
  return fill_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_fill() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return _internal_mutable_fill();
}
inline void ShapeEntity_ShapeStyle::set_allocated_fill(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    
  } else {
    
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
inline bool ShapeEntity_ShapeStyle::_internal_has_stroke() const {
  return this != internal_default_instance() && stroke_ != nullptr;
}
inline bool ShapeEntity_ShapeStyle::has_stroke() const {
  return _internal_has_stroke();
}
inline void ShapeEntity_ShapeStyle::clear_stroke() {
  if (GetArena() == nullptr && stroke_ != nullptr) {
    delete stroke_;
  }
  stroke_ = nullptr;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::_internal_stroke() const {
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* p = stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor&>(
      ::com::opensource::svga::_ShapeEntity_ShapeStyle_RGBAColor_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::stroke() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return _internal_stroke();
}
inline void ShapeEntity_ShapeStyle::unsafe_arena_set_allocated_stroke(
    ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_);
  }
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_stroke() {
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = stroke_;
  stroke_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = stroke_;
  stroke_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::_internal_mutable_stroke() {
  
  if (stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor>(GetArena());
    stroke_ = p;
  }
  return stroke_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_stroke() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return _internal_mutable_stroke();
}
inline void ShapeEntity_ShapeStyle::set_allocated_stroke(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    
  } else {
    
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
}

// float strokeWidth = 3;
inline void ShapeEntity_ShapeStyle::clear_strokewidth() {
  strokewidth_ = 0;
}
inline float ShapeEntity_ShapeStyle::_internal_strokewidth() const {
  return strokewidth_;
}
inline float ShapeEntity_ShapeStyle::strokewidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
  return _internal_strokewidth();
}
inline void ShapeEntity_ShapeStyle::_internal_set_strokewidth(float value) {
  
  strokewidth_ = value;
}
inline void ShapeEntity_ShapeStyle::set_strokewidth(float value) {
  _internal_set_strokewidth(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
inline void ShapeEntity_ShapeStyle::clear_linecap() {
  linecap_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::_internal_linecap() const {
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap >(linecap_);
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::linecap() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
  return _internal_linecap();
}
inline void ShapeEntity_ShapeStyle::_internal_set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value) {
  
  linecap_ = value;
}
inline void ShapeEntity_ShapeStyle::set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value) {
  _internal_set_linecap(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
inline void ShapeEntity_ShapeStyle::clear_linejoin() {
  linejoin_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::_internal_linejoin() const {
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin >(linejoin_);
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::linejoin() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
  return _internal_linejoin();
}
inline void ShapeEntity_ShapeStyle::_internal_set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value) {
  
  linejoin_ = value;
}
inline void ShapeEntity_ShapeStyle::set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value) {
  _internal_set_linejoin(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
}

// float miterLimit = 6;
inline void ShapeEntity_ShapeStyle::clear_miterlimit() {
  miterlimit_ = 0;
}
inline float ShapeEntity_ShapeStyle::_internal_miterlimit() const {
  return miterlimit_;
}
inline float ShapeEntity_ShapeStyle::miterlimit() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
  return _internal_miterlimit();
}
inline void ShapeEntity_ShapeStyle::_internal_set_miterlimit(float value) {
  
  miterlimit_ = value;
}
inline void ShapeEntity_ShapeStyle::set_miterlimit(float value) {
  _internal_set_miterlimit(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
}

// float lineDashI = 7;
inline void ShapeEntity_ShapeStyle::clear_linedashi() {
  linedashi_ = 0;
}
inline float ShapeEntity_ShapeStyle::_internal_linedashi() const {
  return linedashi_;
}
inline float ShapeEntity_ShapeStyle::linedashi() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
  return _internal_linedashi();
}
inline void ShapeEntity_ShapeStyle::_internal_set_linedashi(float value) {
  
  linedashi_ = value;
}
inline void ShapeEntity_ShapeStyle::set_linedashi(float value) {
  _internal_set_linedashi(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
}

// float lineDashII = 8;
inline void ShapeEntity_ShapeStyle::clear_linedashii() {
  linedashii_ = 0;
}
inline float ShapeEntity_ShapeStyle::_internal_linedashii() const {
  return linedashii_;
}
inline float ShapeEntity_ShapeStyle::linedashii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
  return _internal_linedashii();
}
inline void ShapeEntity_ShapeStyle::_internal_set_linedashii(float value) {
  
  linedashii_ = value;
}
inline void ShapeEntity_ShapeStyle::set_linedashii(float value) {
  _internal_set_linedashii(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
}

// float lineDashIII = 9;
inline void ShapeEntity_ShapeStyle::clear_linedashiii() {
  linedashiii_ = 0;
}
inline float ShapeEntity_ShapeStyle::_internal_linedashiii() const {
  return linedashiii_;
}
inline float ShapeEntity_ShapeStyle::linedashiii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
  return _internal_linedashiii();
}
inline void ShapeEntity_ShapeStyle::_internal_set_linedashiii(float value) {
  
  linedashiii_ = value;
}
inline void ShapeEntity_ShapeStyle::set_linedashiii(float value) {
  _internal_set_linedashiii(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
}

// -------------------------------------------------------------------

// ShapeEntity

// .com.opensource.svga.ShapeEntity.ShapeType type = 1;
inline void ShapeEntity::clear_type() {
  type_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeType ShapeEntity::_internal_type() const {
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeType >(type_);
}
inline ::com::opensource::svga::ShapeEntity_ShapeType ShapeEntity::type() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.type)
  return _internal_type();
}
inline void ShapeEntity::_internal_set_type(::com::opensource::svga::ShapeEntity_ShapeType value) {
  
  type_ = value;
}
inline void ShapeEntity::set_type(::com::opensource::svga::ShapeEntity_ShapeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.type)
}

// .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
inline bool ShapeEntity::_internal_has_shape() const {
  return args_case() == kShape;
}
inline bool ShapeEntity::has_shape() const {
  return _internal_has_shape();
}
inline void ShapeEntity::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline void ShapeEntity::clear_shape() {
  if (_internal_has_shape()) {
    if (GetArena() == nullptr) {
      delete args_.shape_;
    }
    clear_has_args();
  }
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::release_shape() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.shape)
  if (_internal_has_shape()) {
    clear_has_args();
      ::com::opensource::svga::ShapeEntity_ShapeArgs* temp = args_.shape_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    args_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::opensource::svga::ShapeEntity_ShapeArgs& ShapeEntity::_internal_shape() const {
  return _internal_has_shape()
      ? *args_.shape_
      : reinterpret_cast< ::com::opensource::svga::ShapeEntity_ShapeArgs&>(::com::opensource::svga::_ShapeEntity_ShapeArgs_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_ShapeArgs& ShapeEntity::shape() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.shape)
  return _internal_shape();
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.opensource.svga.ShapeEntity.shape)
  if (_internal_has_shape()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_ShapeArgs* temp = args_.shape_;
    args_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeEntity::unsafe_arena_set_allocated_shape(::com::opensource::svga::ShapeEntity_ShapeArgs* shape) {
  clear_args();
  if (shape) {
    set_has_shape();
    args_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.shape)
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::_internal_mutable_shape() {
  if (!_internal_has_shape()) {
    clear_args();
    set_has_shape();
    args_.shape_ = CreateMaybeMessage< ::com::opensource::svga::ShapeEntity_ShapeArgs >(GetArena());
  }
  return args_.shape_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::mutable_shape() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.shape)
  return _internal_mutable_shape();
}

// .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
inline bool ShapeEntity::_internal_has_rect() const {
  return args_case() == kRect;
}
inline bool ShapeEntity::has_rect() const {
  return _internal_has_rect();
}
inline void ShapeEntity::set_has_rect() {
  _oneof_case_[0] = kRect;
}
inline void ShapeEntity::clear_rect() {
  if (_internal_has_rect()) {
    if (GetArena() == nullptr) {
      delete args_.rect_;
    }
    clear_has_args();
  }
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::release_rect() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.rect)
  if (_internal_has_rect()) {
    clear_has_args();
      ::com::opensource::svga::ShapeEntity_RectArgs* temp = args_.rect_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    args_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::opensource::svga::ShapeEntity_RectArgs& ShapeEntity::_internal_rect() const {
  return _internal_has_rect()
      ? *args_.rect_
      : reinterpret_cast< ::com::opensource::svga::ShapeEntity_RectArgs&>(::com::opensource::svga::_ShapeEntity_RectArgs_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_RectArgs& ShapeEntity::rect() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.rect)
  return _internal_rect();
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::unsafe_arena_release_rect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.opensource.svga.ShapeEntity.rect)
  if (_internal_has_rect()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_RectArgs* temp = args_.rect_;
    args_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeEntity::unsafe_arena_set_allocated_rect(::com::opensource::svga::ShapeEntity_RectArgs* rect) {
  clear_args();
  if (rect) {
    set_has_rect();
    args_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.rect)
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::_internal_mutable_rect() {
  if (!_internal_has_rect()) {
    clear_args();
    set_has_rect();
    args_.rect_ = CreateMaybeMessage< ::com::opensource::svga::ShapeEntity_RectArgs >(GetArena());
  }
  return args_.rect_;
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::mutable_rect() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.rect)
  return _internal_mutable_rect();
}

// .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
inline bool ShapeEntity::_internal_has_ellipse() const {
  return args_case() == kEllipse;
}
inline bool ShapeEntity::has_ellipse() const {
  return _internal_has_ellipse();
}
inline void ShapeEntity::set_has_ellipse() {
  _oneof_case_[0] = kEllipse;
}
inline void ShapeEntity::clear_ellipse() {
  if (_internal_has_ellipse()) {
    if (GetArena() == nullptr) {
      delete args_.ellipse_;
    }
    clear_has_args();
  }
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::release_ellipse() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ellipse)
  if (_internal_has_ellipse()) {
    clear_has_args();
      ::com::opensource::svga::ShapeEntity_EllipseArgs* temp = args_.ellipse_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    args_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::opensource::svga::ShapeEntity_EllipseArgs& ShapeEntity::_internal_ellipse() const {
  return _internal_has_ellipse()
      ? *args_.ellipse_
      : reinterpret_cast< ::com::opensource::svga::ShapeEntity_EllipseArgs&>(::com::opensource::svga::_ShapeEntity_EllipseArgs_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_EllipseArgs& ShapeEntity::ellipse() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ellipse)
  return _internal_ellipse();
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::unsafe_arena_release_ellipse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.opensource.svga.ShapeEntity.ellipse)
  if (_internal_has_ellipse()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_EllipseArgs* temp = args_.ellipse_;
    args_.ellipse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeEntity::unsafe_arena_set_allocated_ellipse(::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse) {
  clear_args();
  if (ellipse) {
    set_has_ellipse();
    args_.ellipse_ = ellipse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.ellipse)
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::_internal_mutable_ellipse() {
  if (!_internal_has_ellipse()) {
    clear_args();
    set_has_ellipse();
    args_.ellipse_ = CreateMaybeMessage< ::com::opensource::svga::ShapeEntity_EllipseArgs >(GetArena());
  }
  return args_.ellipse_;
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::mutable_ellipse() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ellipse)
  return _internal_mutable_ellipse();
}

// .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
inline bool ShapeEntity::_internal_has_styles() const {
  return this != internal_default_instance() && styles_ != nullptr;
}
inline bool ShapeEntity::has_styles() const {
  return _internal_has_styles();
}
inline void ShapeEntity::clear_styles() {
  if (GetArena() == nullptr && styles_ != nullptr) {
    delete styles_;
  }
  styles_ = nullptr;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle& ShapeEntity::_internal_styles() const {
  const ::com::opensource::svga::ShapeEntity_ShapeStyle* p = styles_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::ShapeEntity_ShapeStyle&>(
      ::com::opensource::svga::_ShapeEntity_ShapeStyle_default_instance_);
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle& ShapeEntity::styles() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.styles)
  return _internal_styles();
}
inline void ShapeEntity::unsafe_arena_set_allocated_styles(
    ::com::opensource::svga::ShapeEntity_ShapeStyle* styles) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(styles_);
  }
  styles_ = styles;
  if (styles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.styles)
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::release_styles() {
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle* temp = styles_;
  styles_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::unsafe_arena_release_styles() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.styles)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle* temp = styles_;
  styles_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::_internal_mutable_styles() {
  
  if (styles_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::ShapeEntity_ShapeStyle>(GetArena());
    styles_ = p;
  }
  return styles_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::mutable_styles() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.styles)
  return _internal_mutable_styles();
}
inline void ShapeEntity::set_allocated_styles(::com::opensource::svga::ShapeEntity_ShapeStyle* styles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete styles_;
  }
  if (styles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(styles);
    if (message_arena != submessage_arena) {
      styles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, styles, submessage_arena);
    }
    
  } else {
    
  }
  styles_ = styles;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.styles)
}

// .com.opensource.svga.Transform transform = 11;
inline bool ShapeEntity::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool ShapeEntity::has_transform() const {
  return _internal_has_transform();
}
inline void ShapeEntity::clear_transform() {
  if (GetArena() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::com::opensource::svga::Transform& ShapeEntity::_internal_transform() const {
  const ::com::opensource::svga::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::Transform&>(
      ::com::opensource::svga::_Transform_default_instance_);
}
inline const ::com::opensource::svga::Transform& ShapeEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.transform)
  return _internal_transform();
}
inline void ShapeEntity::unsafe_arena_set_allocated_transform(
    ::com::opensource::svga::Transform* transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.ShapeEntity.transform)
}
inline ::com::opensource::svga::Transform* ShapeEntity::release_transform() {
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::Transform* ShapeEntity::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::Transform* ShapeEntity::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::Transform>(GetArena());
    transform_ = p;
  }
  return transform_;
}
inline ::com::opensource::svga::Transform* ShapeEntity::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.transform)
  return _internal_mutable_transform();
}
inline void ShapeEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.transform)
}

inline bool ShapeEntity::has_args() const {
  return args_case() != ARGS_NOT_SET;
}
inline void ShapeEntity::clear_has_args() {
  _oneof_case_[0] = ARGS_NOT_SET;
}
inline ShapeEntity::ArgsCase ShapeEntity::args_case() const {
  return ShapeEntity::ArgsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FrameEntity

// float alpha = 1;
inline void FrameEntity::clear_alpha() {
  alpha_ = 0;
}
inline float FrameEntity::_internal_alpha() const {
  return alpha_;
}
inline float FrameEntity::alpha() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.alpha)
  return _internal_alpha();
}
inline void FrameEntity::_internal_set_alpha(float value) {
  
  alpha_ = value;
}
inline void FrameEntity::set_alpha(float value) {
  _internal_set_alpha(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.alpha)
}

// .com.opensource.svga.Layout layout = 2;
inline bool FrameEntity::_internal_has_layout() const {
  return this != internal_default_instance() && layout_ != nullptr;
}
inline bool FrameEntity::has_layout() const {
  return _internal_has_layout();
}
inline void FrameEntity::clear_layout() {
  if (GetArena() == nullptr && layout_ != nullptr) {
    delete layout_;
  }
  layout_ = nullptr;
}
inline const ::com::opensource::svga::Layout& FrameEntity::_internal_layout() const {
  const ::com::opensource::svga::Layout* p = layout_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::Layout&>(
      ::com::opensource::svga::_Layout_default_instance_);
}
inline const ::com::opensource::svga::Layout& FrameEntity::layout() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.layout)
  return _internal_layout();
}
inline void FrameEntity::unsafe_arena_set_allocated_layout(
    ::com::opensource::svga::Layout* layout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layout_);
  }
  layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.FrameEntity.layout)
}
inline ::com::opensource::svga::Layout* FrameEntity::release_layout() {
  
  ::com::opensource::svga::Layout* temp = layout_;
  layout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::Layout* FrameEntity::unsafe_arena_release_layout() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.layout)
  
  ::com::opensource::svga::Layout* temp = layout_;
  layout_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::Layout* FrameEntity::_internal_mutable_layout() {
  
  if (layout_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::Layout>(GetArena());
    layout_ = p;
  }
  return layout_;
}
inline ::com::opensource::svga::Layout* FrameEntity::mutable_layout() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.layout)
  return _internal_mutable_layout();
}
inline void FrameEntity::set_allocated_layout(::com::opensource::svga::Layout* layout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete layout_;
  }
  if (layout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(layout);
    if (message_arena != submessage_arena) {
      layout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layout, submessage_arena);
    }
    
  } else {
    
  }
  layout_ = layout;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.layout)
}

// .com.opensource.svga.Transform transform = 3;
inline bool FrameEntity::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool FrameEntity::has_transform() const {
  return _internal_has_transform();
}
inline void FrameEntity::clear_transform() {
  if (GetArena() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::com::opensource::svga::Transform& FrameEntity::_internal_transform() const {
  const ::com::opensource::svga::Transform* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::Transform&>(
      ::com::opensource::svga::_Transform_default_instance_);
}
inline const ::com::opensource::svga::Transform& FrameEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.transform)
  return _internal_transform();
}
inline void FrameEntity::unsafe_arena_set_allocated_transform(
    ::com::opensource::svga::Transform* transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.FrameEntity.transform)
}
inline ::com::opensource::svga::Transform* FrameEntity::release_transform() {
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::Transform* FrameEntity::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::Transform* FrameEntity::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::Transform>(GetArena());
    transform_ = p;
  }
  return transform_;
}
inline ::com::opensource::svga::Transform* FrameEntity::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.transform)
  return _internal_mutable_transform();
}
inline void FrameEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.transform)
}

// string clipPath = 4;
inline void FrameEntity::clear_clippath() {
  clippath_.ClearToEmpty();
}
inline const std::string& FrameEntity::clippath() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.clipPath)
  return _internal_clippath();
}
inline void FrameEntity::set_clippath(const std::string& value) {
  _internal_set_clippath(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.clipPath)
}
inline std::string* FrameEntity::mutable_clippath() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.clipPath)
  return _internal_mutable_clippath();
}
inline const std::string& FrameEntity::_internal_clippath() const {
  return clippath_.Get();
}
inline void FrameEntity::_internal_set_clippath(const std::string& value) {
  
  clippath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FrameEntity::set_clippath(std::string&& value) {
  
  clippath_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.FrameEntity.clipPath)
}
inline void FrameEntity::set_clippath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clippath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.FrameEntity.clipPath)
}
inline void FrameEntity::set_clippath(const char* value,
    size_t size) {
  
  clippath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.FrameEntity.clipPath)
}
inline std::string* FrameEntity::_internal_mutable_clippath() {
  
  return clippath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FrameEntity::release_clippath() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.clipPath)
  return clippath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameEntity::set_allocated_clippath(std::string* clippath) {
  if (clippath != nullptr) {
    
  } else {
    
  }
  clippath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clippath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.clipPath)
}

// repeated .com.opensource.svga.ShapeEntity shapes = 5;
inline int FrameEntity::_internal_shapes_size() const {
  return shapes_.size();
}
inline int FrameEntity::shapes_size() const {
  return _internal_shapes_size();
}
inline void FrameEntity::clear_shapes() {
  shapes_.Clear();
}
inline ::com::opensource::svga::ShapeEntity* FrameEntity::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >*
FrameEntity::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.FrameEntity.shapes)
  return &shapes_;
}
inline const ::com::opensource::svga::ShapeEntity& FrameEntity::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::com::opensource::svga::ShapeEntity& FrameEntity::shapes(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.shapes)
  return _internal_shapes(index);
}
inline ::com::opensource::svga::ShapeEntity* FrameEntity::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::com::opensource::svga::ShapeEntity* FrameEntity::add_shapes() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.FrameEntity.shapes)
  return _internal_add_shapes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >&
FrameEntity::shapes() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.FrameEntity.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MovieEntity

// string version = 1;
inline void MovieEntity::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& MovieEntity::version() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.version)
  return _internal_version();
}
inline void MovieEntity::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieEntity.version)
}
inline std::string* MovieEntity::mutable_version() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.version)
  return _internal_mutable_version();
}
inline const std::string& MovieEntity::_internal_version() const {
  return version_.Get();
}
inline void MovieEntity::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MovieEntity::set_version(std::string&& value) {
  
  version_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.MovieEntity.version)
}
inline void MovieEntity::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.MovieEntity.version)
}
inline void MovieEntity::set_version(const char* value,
    size_t size) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.MovieEntity.version)
}
inline std::string* MovieEntity::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MovieEntity::release_version() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MovieEntity::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.version)
}

// .com.opensource.svga.MovieParams params = 2;
inline bool MovieEntity::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool MovieEntity::has_params() const {
  return _internal_has_params();
}
inline void MovieEntity::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::com::opensource::svga::MovieParams& MovieEntity::_internal_params() const {
  const ::com::opensource::svga::MovieParams* p = params_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::opensource::svga::MovieParams&>(
      ::com::opensource::svga::_MovieParams_default_instance_);
}
inline const ::com::opensource::svga::MovieParams& MovieEntity::params() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.params)
  return _internal_params();
}
inline void MovieEntity::unsafe_arena_set_allocated_params(
    ::com::opensource::svga::MovieParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.opensource.svga.MovieEntity.params)
}
inline ::com::opensource::svga::MovieParams* MovieEntity::release_params() {
  
  ::com::opensource::svga::MovieParams* temp = params_;
  params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::opensource::svga::MovieParams* MovieEntity::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.params)
  
  ::com::opensource::svga::MovieParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::com::opensource::svga::MovieParams* MovieEntity::_internal_mutable_params() {
  
  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::opensource::svga::MovieParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::com::opensource::svga::MovieParams* MovieEntity::mutable_params() {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.params)
  return _internal_mutable_params();
}
inline void MovieEntity::set_allocated_params(::com::opensource::svga::MovieParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.params)
}

// map<string, bytes> images = 3;
inline int MovieEntity::_internal_images_size() const {
  return images_.size();
}
inline int MovieEntity::images_size() const {
  return _internal_images_size();
}
inline void MovieEntity::clear_images() {
  images_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MovieEntity::_internal_images() const {
  return images_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MovieEntity::images() const {
  // @@protoc_insertion_point(field_map:com.opensource.svga.MovieEntity.images)
  return _internal_images();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MovieEntity::_internal_mutable_images() {
  return images_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MovieEntity::mutable_images() {
  // @@protoc_insertion_point(field_mutable_map:com.opensource.svga.MovieEntity.images)
  return _internal_mutable_images();
}

// repeated .com.opensource.svga.SpriteEntity sprites = 4;
inline int MovieEntity::_internal_sprites_size() const {
  return sprites_.size();
}
inline int MovieEntity::sprites_size() const {
  return _internal_sprites_size();
}
inline void MovieEntity::clear_sprites() {
  sprites_.Clear();
}
inline ::com::opensource::svga::SpriteEntity* MovieEntity::mutable_sprites(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >*
MovieEntity::mutable_sprites() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.sprites)
  return &sprites_;
}
inline const ::com::opensource::svga::SpriteEntity& MovieEntity::_internal_sprites(int index) const {
  return sprites_.Get(index);
}
inline const ::com::opensource::svga::SpriteEntity& MovieEntity::sprites(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.sprites)
  return _internal_sprites(index);
}
inline ::com::opensource::svga::SpriteEntity* MovieEntity::_internal_add_sprites() {
  return sprites_.Add();
}
inline ::com::opensource::svga::SpriteEntity* MovieEntity::add_sprites() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.sprites)
  return _internal_add_sprites();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >&
MovieEntity::sprites() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.sprites)
  return sprites_;
}

// repeated .com.opensource.svga.AudioEntity audios = 5;
inline int MovieEntity::_internal_audios_size() const {
  return audios_.size();
}
inline int MovieEntity::audios_size() const {
  return _internal_audios_size();
}
inline void MovieEntity::clear_audios() {
  audios_.Clear();
}
inline ::com::opensource::svga::AudioEntity* MovieEntity::mutable_audios(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.audios)
  return audios_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::AudioEntity >*
MovieEntity::mutable_audios() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.audios)
  return &audios_;
}
inline const ::com::opensource::svga::AudioEntity& MovieEntity::_internal_audios(int index) const {
  return audios_.Get(index);
}
inline const ::com::opensource::svga::AudioEntity& MovieEntity::audios(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.audios)
  return _internal_audios(index);
}
inline ::com::opensource::svga::AudioEntity* MovieEntity::_internal_add_audios() {
  return audios_.Add();
}
inline ::com::opensource::svga::AudioEntity* MovieEntity::add_audios() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.audios)
  return _internal_add_audios();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::opensource::svga::AudioEntity >&
MovieEntity::audios() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.audios)
  return audios_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace svga
}  // namespace opensource
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap>() {
  return ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap_descriptor();
}
template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin>() {
  return ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin_descriptor();
}
template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeType>() {
  return ::com::opensource::svga::ShapeEntity_ShapeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_svga_2eproto
